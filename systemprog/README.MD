Системное программирование - изучение новой операционной системы(задания 2-х уровней сложности)
первое задание:
![image](https://user-images.githubusercontent.com/97594420/215027057-029c11d1-9838-4cae-acd5-0c5ae0126bb3.png)
![image](https://user-images.githubusercontent.com/97594420/215028209-f6b47962-deaf-420c-b38d-58bfe533866a.png)




ЛК1 
<br> История операционных систем 
ЭВМ 1-го поколения ОС пока не существует 
<br> Предпосылки 
1943 год - устройство для расчёта баллистической таблицы 
Время сокращают создав ЭНИАК 
<br> ЭНИАК - первый электронный дифференциальный анализатор 
<br> 1. Использование ласмп 
<br> 2. возможность перепрограммирования 
Используется перфокарта   
Построен на лампах  
Десятичное исчисление  
<br> Недостатки: 
Для решения систем диф.уровнений примерно 1 млн перфокарт, более 17 тыс.ламп 
лампы => греются и горят 
перфокарта => на перепрограммирование 2 и более дней 
<br> Архитектура фон Неймана 
<br> Двоичная система(есть сигнал - 1, нет сигнала - 0) 
<br> Уходит от перфокарт и приходит на пронумированные ячейки 
<br> Программа это последовательность команд, выполняемые последовательно 
!image 
УУ - дешифрует команды, считает и хранит их регистры 
<br> ЭВМ 2-го поколения. Первые языки программирования 
переход на транзисторы с ламп (они меньше размера, не выделаяют тепла, большая скорость переключения, высокая надежность - нет перегорающей нити, можно использовать плотную компановку) (проблемы соединений - плотная компановка затрудняла диагностику, дороговизна производства, большой шум выходного сигнала, чем у ламп) 
 
<br> Второе поколение ЭВМ 
<BR> Упрощение процесса разработки => появление программистов ЭВМ 
  - [X] Появление алгоритмических языков 
  - [X] Компилятор 
<br> Повышенная эффективность времени работы компьютера 
  - [X] Пакетная обработка заданий 
  - [X] Формализованный язык управления заданиями 
 <BR> ЭВМ 3-4го поколения 
 <br> Появление интегральных схем 
 <br> 60-е годы 
 <br> 3-ие поколения миллион операция в секунду, 4-ие 10 миллионов. 
 <br> Плюсы интегральных схем: 
   - [X] Автоматизация производства => уменьшение стоимости 
 <BR> Четвёртое поколение ЭВМ 
 <BR> Решает проблемы многозадачности, виртуальная память(запускается только та часть программы, требующее для выполнения) 
 <br> Базы данных 
 <br> Появляется apple и Unix(32-ух разрядная ОС) 
 <br> вместо перфокарт - магнитные ленты и  диски 
   UNIX (конец 60-ых) 
   - самописная файловая система 
   - коммандная оболочка 
   - утилиты 
   80-ые - языки С 
   linux 
   - 80-ые появляется стек протоколов TCP/IP (транспортный сетевой протокол - протокол передачи данных) (этот протокол определил, что инфо. дробится на пакеты, у каждого из которых есть IP или уникальный номер, что позволяет отслеживать их передачу) 
  linux, Линус Торвальдс (1991) 
   1991 - изобретение GNU(бесплатные утилиты gcc, bash(контроль версий или гит)) 
   - появление системных вызовов UNIX 
   - монолитное ядро 
   Функции ОС 
   - обеспечение выполнения программ 
     + выделение процессорного времени 
     + выделение памяти, загрузка в памяти исполняемой программы 
     + обработка системных вызовов 
     + ввод и вывод данных 
   - управление памятью системы 
     + ограничение доступа к устройством посредством файловых систем 
     + Стандартизированный доступ к устройствам ввода и вывода 
     + обеспечение безопасности 
     + организация сетевого стека 
   Монолитное ядро 
 
микроядерное архитектура - WINDOWS 
  
совместимость ОС: двоичная и на уровне исходных кодов 
   Двоичный (запуск exe файла) 
   Исходных кодов (передается файл с кодом) 
  
<BR> Файловая абстракция в UNIX 
  В unix все есть файл (клавиатура, флешка и т.д.) 
  Заголовки типы файлов 
   1. символьные устройства(клавиатура) 
   2. Блочные устройства(флешки) 
   3. каталоги(папки) 
   4. Ссылки(ярлык) 
   5. Именованные каналы(связь) 
   6. Сокеты(узлы связи) 
 



Unix-подобных систем:  
  1. Linux и MacOS 
  2. Дистрибутив Unix(Debian, Arch Linux, Red Hat) 
  3. Ubuntu основан на Debian 
  4. Kali Linux - для инфобезников, российские системы: АстраЛинукс 
  
<br>Переключение в режим администратора:!image 
<br>Переключение языка:Shift + Пробел 
<br>Изменить размер шрифта вкладка Стиль:!image 
<br>Файловая система:
<br>!возможность копировать на Debian 

  
<br> задание 2. 
  <br> работа с файлами 
  <BR> Операция: создать, написать, прочитать, удалить, проверить 

    !Снимок экрана (23)    
     

ctrl+c чтобы выйти из сокета 
  




# ЛК5

 

list_a=[]
list_b=[1,2,3]
print(list_a)

if list_a: # = if list_a == []:
  print("список не пустой")
else:
  print("список пустой") 
#первая запись равна второй

if not list_a: # = if list_a != []:
  print("список не пустой")
else:
  print("список пустой") 


#замена элемента по индексу
mas = [1, 2, 3, 'четыре']
print(mas)
mas[0] = 'один'
print(mas)
mas[-1] = 4 # mas[3] = 4
print(mas)

#списки срезы
# [от : до : шаг]
print(mas[1:4:2])
#[от : до]
print(mas[1:4])
# с 1 по -1 (не включительно)
print(mas[0:-1])

#списки. функции slice()
a=list('abcdef')
#slice(начало, конец, шаг)
x = slice(1,4,2)
print(a[x])
print(a[1:4:2])
print(x)
print(mas[x])

#замена нескольких эелементов
mas[1:4] = [5,6,7]
print(mas)

#добавление элементов
mas.append(88)
print(mas)
#добавить в конец
mas.insert(1, 200)
print(mas)
#в определенное место
mas.extend([6, 99])
print(mas)
#добавление одного списка в другой
a.extend(mas)
print(a)

#удаление элементов
#удаление элемента по индексу
del mas[3]
print(mas)
#удаление всех элементов
del a[:]
print(a)
# или
mas.clear()
print(mas)

# сохранить удаленный элемент
mas = [1,2,3]
deleted_element = mas.pop()
print(mas)
print(deleted_element)

# удаление когда есть повторы
mas = [1,2,3,3, 2, 2, 5, 5, 5]
print(mas)
del mas[2]
print(mas)
mas.remove(3)
print(mas)

for i in mas:
  mas.remove(5)
print(mas)
'''
#ЛК1
#сортировка
#один тип данных
mas = [11, 33, 3, 4, 2, 5]
mas.sort()
print("Сортировка", mas)
mas.reverse()
print("Обратная сортировка", mas)
cars = ['bmw', 'audi', 'toyota', 'subaru']
cars.reverse()
print("Обратная сортировка строк", cars)

mas.insert(2, "44")
#разные типы данных
#сортировка по правилам сортировки строк
mas.sort(key = str)
print("Сортировка", mas)

#сортировка по правилам сортировки чисел
mas.sort(key = int)
print("Сортировка", mas)

#получить индекс элемента, выводит первый индекс
print("Индекс", mas.index(2))
#количество элементов x - список.count(x)
print("количество элементов 4", mas.count(4))
#длина списка
print("длина списка", len(mas))
mas.extend([3, 5])

mas=[1,3,2,3,2,2,3,3,5]
a=[]
print(mas)
for i in mas:
  if mas.count(i) > 1:
    print(i)
    a.extend([i])
    mas[i] = 5
    mas[mas.index(i)] = 5
print("test", a)
#i - сам элемент
print(mas)

#агрегирование
#миниальный элемент числового индекс
print(min(mas))
#максимальный
print(max(mas))
#сумма
print(sum(mas))
#среднее
print(sum(mas)/len(mas))

#метод split()
stroka = '1 2 что-то 7 99 там'
list_stroka = stroka.split()
print(list_stroka)
fio = "Солдатова Евгения Александровна"
fionew = fio.split()

print(fionew[0] + " " + fionew[1][0] + ". "  + fionew[2][0] + ". ")

#30.01.2023
mas = [5, 4, 6]
mas2 =[3, 4]
mas3=mas+mas2
mas0 = 3, 4
print(mas3)
mas.extend(mas2)
print(mas)
mas4="try", "text"
mas5 = "hello", "world"
mas.extend(mas5)
mas2.extend(mas)
print(mas4)
print(mas)
#join - работа со строками
print("_".join(mas4))
print(mas4[0] + "_" + mas4[1])

#разделить на 2 списка в один цифры, во-второй строки
masint = []
masstring = []
for i in mas[:4]:
    if type(i) == int:
        masint.append(i)
    else:
        masstring.append(i)
print(masint)
print(masstring)
'''
#генераторы - возможность создать список одной строкой
gener = [i**2 for i in range (11, 20) if i%2 == 0]
print(gener)
# 1. ввод числа пользователем 2. Определить, есть ли числа в списке
chislo = int(input("введите число: "))

if chislo ** 2 in gener:
    print("квадрат есть")
    '''
# словари: пара, которая состоит из ключа и значения
book = {"avtor" : "Жюлб Верн" , "title": "название книги", "count" : 4}
print(book["count"])
for i in book:
    print(book[i])
print(len(book))

gener = {i: i**2 for i in range (11, 20) if i%2 == 0}
print(gener)
#способы добавления
book["year"] = 2023
print(book)

book.update({"number of pages": 200})
print(book)
#удаление
del book["year"]
print(book)
book.clear()
print(book)

